## JavaScript糟粕部分

JavaScript是一门优秀的语言，但是难免存在着某些缺点，本博文主要说明下JavaScript的一些缺点。

JavaScript有两组相等的运算符：===和!==，以及他们邪恶的孪生兄弟==和!=。===和!==运算符能够按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么===就返回true，!==返回false。但是**==和!=**只有在两个运算符类型一致时才会做出正确的判断，如果两个运算数是不同的类型，他们试图去强制转换值的类型。转换的规则复杂难以记忆。下面的一些有趣的例子：

```
传递性
'0' == 0 # true
 0 == '' # true
'' == '0' # false   为什么不是true呢

false == 'false' # false
false == 0 # true

false == undefined # false
false == null # false
null == undefined # true

'\t\r\n' == 0 # true
```

==运算符对传递性的缺乏值值得我们警惕。最好永远不要使用那对邪恶的孪生兄弟。相反的，请始终使用===和!==。如果上面的比较都是用===运算符，结果都是false，在编程中规定使用，很是受益。

传递性是一种编程约定。可以理解：对于任意的引用值x、y和z，如果x == y 和 y == z 为 ture，那么 x == z 为true。而JavaScript中的 == 运算符在某种特例上违背了传递性。

### ++ --

递增和递减运算符使得程序员可以用非常简洁的风格去编码。比如在C语言中，它们使得用一行代码实现字符串的复制成为可能：

for(p = src, q = dest; *p; p++, q++) *q = *p;

事实上，这两个运算符鼓励了一种不够严谨的编码风格。大多数的缓冲区溢出错误所造成的安全漏洞，都是由像这样编码而导致的。

当使用++ 和 --时，代码往往过于拥挤、复杂和隐晦。因此，作为一条原则，我不再使用它们。团队上也可以规范一波，那样我们的代码风格会变得更加整洁。

### 位运算符

JavaScript有着和Java相同的一套位运算符：

```
&	and 按位与
|	or 按位或
^	xor 按位异或
~	not 按位非
>>	带符号的右移动
>>>		无符号的（用0补足的）右移动
<< 左位移
```

在Java中，位运算符处理的是整数。JavaScript没有整数类型，它只有双精度的浮点数。因此，位操作符吧它们的数字运算数先转换成整数，接着执行运算，然后再转换回去。在大多数语言中，这些运算符接近于硬件处理，所以非常快。但JavaScript的执行环境一般接触不到硬件，所以非常慢。JavaScript很少被用来执行位操作。

### function语句对比function表达式

avaScript既有function语句，同时也有function表达式。这令人困惑，因为它们看起来好像是相同的。一个function语句就是其值为一个函数的var语句的速记形式。

```
function foo() {}
```
意思相当于：
```
var foo = function foo() {}
```

第二种写法相对友好，因为它明确表示foo是一个包含一个函数值的变量。要学好JavaScript这门语言，理解函数就是数值是很重要的。

unction语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域顶层。这就放宽了函数必须先声明后使用的要求，这会导致混乱的。在if语句中使用function语句也是被禁止的。结果表明大多数的浏览器都允许在if语句里使用function语句，但是它们在解析的时候处理上各不相同。这就造成了可移植性的问题。

一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句。解决的方法就是把函数调用括在一个圆括号中。

```
(function () {
	var hidden_variable;
	
	# 这个函数可能对环境有一些影响，但是不会映入新的全局变量
})();
```

### 类型的包装对象

JavaScript有一套类型的包装对象。例如：

new Boolean(false)

会返回一个对象，该对象有一个valueOf方法会返回被包装的值。这其实完全没有必要，并且有时还令人困惑。不要使用new Boolean、new Number 或 new String。

此外，页应该避免使用new Object 和 new Array。可使用{} 和 []来替代。

### new

JavaScript的new运算符创建了一个继承于其运算符的原型的新对象，然后调用该运算数，把新创建的对象绑定给this。这给运算数（它应该是一个构造函数）一个机会在返回给请求者自定义新创建对象。
如果忘记了使用此new运算符，你得到的就是一个普通的函数调用，并且this被绑定到全局对象，而不是新创建的对象。者意味着当你的函数尝试去初始化新成员属性时它将会污染全局变量。这是一件非常糟糕的事情。而且既没有编译时警告，也没有运行时警告。
按照惯例，打算与new结合使用的函数应该以首字母大写的形式命名，并且首字母大写的形式应该只用来命名那些构造器函数。这个约定帮助我们进行区分，便于我们发现那些Javascript语言自身经常忽略但是却带来昂贵代价的错误。
一个更好的应对方法策略是根本不去使用new。幻想下就行啦～

### void

在很多语言中，void 是一种类型，表示没有值（空值）。而在JavaScript中，void是一个运算符，它接受一个运算数并且返回undefined。

```function getValue(){
   a = void ( a = 90 );
   document.write('a = ' + a); # a = undefined
} 
```
这并没有什么用，而且令人非常困惑。应该避免使用。